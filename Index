// This class creates a CDFG, performs ALAP scheduling, and List_R

// I've been unable to test because my laptop broke and I am using a rental.

public class list_r {
	private V[] vertices;
	private v_id;
	
	public list_r() {
		vertices = new V[];
		
		V.add(new V(0, null, null, true) );	// Top Sink node
		V.add(new V(-1, null, null, true) );	// Bottom Sink node
		
		v_id = 1;
	}
	
	// Adds all vertices for specified section.
	// This gets called after all the declarations have been instantiated in the verilog file.
	// Variable "x" is the first line of statements in the input file'
	public void addVertices(String[] lines, int x) {
		
		// Adds new vertex for each statement
		for(int i = x; i < lines.length; i++) {
			String[] line = tokenize(lines[i], " ");
			String operator = line[line.length - 2];
			vertices.add(new V(v_id, operator, line[0]) );	// Adds new vertex
			v_id++;
		}
	}
	
	// Searches for dependencies within the statements
	public void addDependencies(String[] lines, int x) {
		
		Set<String> set = new HashSet<String>();		// Set to hold variables already worked on (dependencies)
		
		for(int i = x; i < lines.length; i++ ) {
			String[] line = tokenize(lines[i], " ");
			
			// HAVE NOT ACCOUNTED FOR IF STATEMENTS YET
			// Determine if case: o = sel ? i1 : i0... I have not accounted for this case yet
			if(line[line.length-2] != ":") {
				String var = line[0];
				String var1 = line[line.length - 3];
				String var2 = line[line.length-1];
				
				// If no dependency, add edge from sink node
				if(!set.contains(var1) && !set.contains(var2)) {	
					findVertex(0).addSuccessor(findVertex(var));		// Adds successor to sink node
					set.add(var);
				}
				else {
					if(set.contains(var1)) {
						findVertex(var1).addSuccessor(findVertex(var));		// Adds successor
					}
					else {
						findVertex(var2).addSuccessor(findVertex(var));		// Adds successor
					}
				}
			}
		}
		
		// Adds dependencies from leaf to bottom Sink node
		for(int j = 0; j < vertices.length; j++) {
			if(vertices[j].getSuccessorSize() == 0) {	// If leaf, add successor to sink node
				vertices[j].addSuccessor(-1);
			}
		}
	}
	
	// Performs ALAP scheduling
	public void alap(int latency) {
		
		int[] timing = new int[vertices.length];		// Array to hold timing of each vertex
		
		// Schedules the sink node for upper latency bound + 1 and sets isScheduled to true
		timing[timing.length - 1] = latency + 1;
		vertices[vertices.length - 1].isScheduled = true;
		
		// whileall vertices are not scheduled, run the algorithm
		while(!allVerticesScheduled()) {
					// Iterate through vertices, find a vertex where all successors are scheduled
					for(int i = 0; i < vertices.length(); i++) {	
					
						V currentV = vertices[i];
						boolean valid = true;		// boolean to check if all successors are scheduled
						int lowestTime = 100;		// For multiple successors, holds minimum time
						int successorDelay = 0;
						 
						if(currentV.isScheduled == false) {			// If vertex is not scheduled, check all it's successors to determine if their scheduled
							V[] successors = currentV.getSuccessors();
							for(int j = 0; j < successors.length(); j++) {
								if(successor[j].isScheduled == false) {
									valid = false;
									break;
								}
								else {
									int index = findVindex(successor[j].id);
									if(timing[index] < lowestTime) {
										lowestTime = timing[index];
										successorDelay = vertices[index].calculateDelay();
									}
								}
							}	
							if(valid == true) {
								timing[i] = lowestTime - successorDelay;
								vertices[i].isScheduled = true;
							}
						}
					}
			}	
		}
	
	public int findV(String varName) {
		for(int i = 0; i < vertices.length; i++) {
			if(vertices[i].varName == varName) {
				return vertices[i].ID;
			}
		}
		return -2;
	}
	
	public int findVindex(int id) {
		for(int i = 0; i < vertices.length(); i++) {
			if(vertices[i].ID == ID) {
				return i;
			}
		}
	}
	
	// Returns true if all vertices scheduled, false otherwise
	public boolean allVerticesScheduled() {
		for(int i = 0; i < vertices.length(); i++) {
			if(vertices[i].isScheduled == false) {
				return false;
			}
		}
		return true;
	}
	
	// Sets the delay for specified operator
	// Multipliers = 2
	// Divider/modulo = 3
	// All others = 1
	public int calculateDelay(String operator) {
		if(operator == "*") {
			return 2;
		}
		else if(operator == "/" || operator == "%") {
			return 3;
		}
		else {
			return 1;
		}
	}
	
}
